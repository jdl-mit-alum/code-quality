# code-quality## Reason &#x2203; this repositoryA gulf lies between the two most common software development practices.In general, there is no expectation that this gulf is to be bridged.There are those who care about qualityto the point of obsession (waterfall) andthere are those who care about getting things doneas quickly as possible (agile).This is the difference between long-term profits and short-term profits.Practitioners on both sides of the gulf are often ignorant of the needsserved on the other side of the gulf, and how they are met.This repository proposes that there exists a disciplineand an ordered series of practices which can takeagile software into waterfall quality.It is possible to choose the degree of quality on-the-flywithout sacrificing the values of either group.In fact, there is a benefit to rapid-prototyping for value discoveryand a benefit to high-quality for persistent delivery under stress.Modern industrial software development has two main approaches:* waterfall: hardened code for high-integrity use* agile: rapidly developed code for testing new marketsSoftware developed for military and scientific use must work.Special care must be taken to harden the code and guarantee operation.A ten-year NASA mission has critical dependency on code quality.This so-called "waterfall" method is brittle and prone to failureunless a long course of detailed planning is executed exactly as proposed.Sometimes years pass before the code is declared ready.The [Common Criteria](https://www.commoncriteriaportal.org/)documents the measure of quality required to declare a system secure.Systems developed under "agile" methodologiestypically cannot achieve significant certification.Software developed by entrepreneurs to pursue a markethas far less dependency on quality guarantees.If the code works over a statistically significant market segmentit is deemed sufficient for direct release to the customer.Perfect operation is neither required nor expected.It is not uncommon for the boundary between working and failing codeto be blurred and for corners to be cut in the pursuit of early results.A description of the values of these developer is given in[the agile manifesto](http://www.agilemanifesto.org/).Key characteristics of quality include:* Social structure (knowing who can answer questions)* Reference (knowing where to find supporting ideas)* Legal restrictions (knowing if permission is given to use the code)* Concept (knowing what the code is supposed to do)* Proof (seeing that the code works)* Constraints (knowing the code works in the environment where you need it)* Standards (syntax and naming compliance)* Documentation (detailed API reference and discussion)* Failures (memory leaks, problem inputs/outputs)## Examples### Python 2.7This directory has modules having above average coding convention care taken.### C++This directory has modules having above average coding convention care taken.## PrinciplesFeatures of quality include:* Strong use of comments* Comments for use of doxygen to produce module documentation* Header comment for module comprehension* Visual cue comments for rapid scanning by eye* Explanation comments for unit tests and their goals* 100% Syntax compliance with lint* Allowable naming conventions for libraries, classes, methods, members* 100% Code coverage* Comparison with known valid output* [PASS]/[FAIL] visual cues for issues* Cleanup to the minimum set of sources* No dead code### CommentsComments add value in many ways:* Identify author/organization/history/legal* Explain what the goal of the code is (problem i.e. input/transform/output)* Explain how the goal is achieved (solution)* Reference literature on solution (possible alternatives)* Describe merits of solution choice (simplicity/maintainability/efficiency)* Explain non-obvious or off-standard coding techniques (i.e. computed goto)* List environments where results have been tested (OS/version/chip/compiler)* Identify architecture/compiler/platform limitations* Example compile instructions* Describe how to run tests* Identify conventions followed* Specifically identify interfaces (call signatures)* Mark quality control exceptions (NOLINT/pragma pylint)* Provide data for automatic document generators (doxygen)* Visual assistance for navigating the source* Describe limitations and directions for future development (todo)* Illustrate usage with a variety of examples* Identify name overloading and explain why name re-use was chosen### Syntax compliance* Identify tool(s) used (lint/pep8/pylint/pyflakes)* Achieve and document 100% compliance* Document exceptions and reasons for exceptions* Identify standard for compliance (pep8/pep20/google c++ style guide)* Explain choice for deviation from standard### Naming conventions* Identify standard (pep20/google c++ style guide)* Explain deviation from standard### Example valid inputs/outputs* Examples of typical use* Examples of "edge/corner" cases illustrating input/output limitations### Unit testing/coverage* Identify where unit tests are stored* Describe how unit tests are run* Set expectations for elapsed time and results* Aid testing with clear identification of test PASS/FAIL results* Identify artifact storage location* Store artifacts* Keep example expected output for comparison* Compare expected output with actual output* Identify problematic differences between expected/actual output* Discovery of dead code### Automatically generate documentation* Identify tool (doxygen/pydoc)* Identify artifact storage location* Generate and store documentation into artifact* Document quality process in documentation root (README.md/index.html)### Resource problems* Describe memory leaks or garbage accumulation (valgrind)